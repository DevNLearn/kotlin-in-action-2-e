
## 코틀린이란 무엇이며, 왜 필요한가?

### 코틀린이란?
**JetBrains에서 자바를 대신할 언어에 대한 필요성을 시작으로 개발되었다**
  - 가장 분명한 요구사항은 정적 타입 지정, 즉 컴파일 시점에 변수나 함수의 타입을 결정하는 것
  - 정적 타입 지정을 가장 필요로 했던 이유?
    - 자바의 동적 타입 지정은 런타임 시점에 오류를 발생시킬 수 있음
    - 정적 타입 지정을 통해 컴파일 시점에 오류를 발견할 수 있어 런타임 오류를 줄일 수 있음
  - '더 나은 자바'를 목표로 한 만큼 자바를 100% 호환되기 때문에 기존 자바 라이브러리 사용 가능

**JVM 및 다중 플랫폼을 위한 정적 타입 언어이다**
- JVM을 타겟으로 했지만 이미 JVM을 넘어 크로스플랫폼 솔루션 제공
    - 크로스플랫폼? 다양한 플랫폼에서 실행될 수 있는 언어, 즉 안드로이드와 IOS 모두에서 실행될 수 있는 언어


### 코틀린의 특징

**정적 타입 지정**
- 모든 식(변수, 함수, 클래스 등)의 타입을 명시적으로 지정
  - 타입 추론을 제공하기 때문에 개발자가 모든 타입을 명시적으로 지정하지 않아도 된다
- 컴파일러를 통해 접근하려는 식의 타입을 미리 확인해 검증

**널이 될 수 있는 타입 지원**
- 자바와 가장 크게 다른 점으로 10억짜리 실수라 불리는 NullPointException 방지

**함수형 프로그래밍과 객체지향 프로그래밍의 조합**
- 코틀린에서 맛보는 함수형 프로그래밍의 장점
  - 함수가 다른 데이터 타입과 동일하게 취급되기 때문에 일반 값으로 사용 가능
    - 함수를 변수에 저장할수도, 인자로 다른 함수에 전달할 수도, 새로운 함수를 생성할 수도 있음
  - 불변 객체를 사용하기 때문에 멀티스레드 환경에서 안전하게 사용 가능
  - 순수 함수를 사용하기 때문에 부작용 최소화 및 동작 예측 가능
    - 순수 함수?
      - 동일한 입력에 대해 항상 동일한 출력 뱉는, 즉 함수의 결과가 함수 내/외부 상태에 의존하지 않음
      - ex) `fun toUpperCase(input: String) = input.uppercase()`
  - 이런 순수 함수로 공통 로직을 뽑아내고 세부적인 설정을 람다식으로 인자로 전달하는 방식으로 구현 
    - ex) `fun <T> List<T>.filter(predicate: (T) -> Boolean): List<T>`
      - 이때 람다식 predicate도 순수 함수로 구현되어야 함
        - 사용 ex) `numList.filter { it != 0 }` 

**코루틴**
- 기존 동시성 처리 시 callback, future, promise 등 복잡한 코드 사용
- 일시 중단 가능한 계산을 사용해 비동기 처리
  - 일시 중단 가능한 계산?
    - 코루틴이 일시 중단되면 다른 코루틴이 실행될 수 있도록 하는 것
    - 즉, 코루틴이 일시 중단되면 다른 코루틴이 실행되고, 다시 돌아오면 이전에 중단된 코루틴이 다시 실행됨
- 코루틴은 스레드보다 가벼운 경량 스레드로, 더 적은 자원을 사용하여 많은 동시 작업을 처리할 수 있음
  - 성능 손해 없이 플로우 같은 추상화를 사용해 동시성 처리 가능

