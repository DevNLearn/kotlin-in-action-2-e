
## 기본 타입, 컬렉션, 배열

**다루는 내용**
- 코틀린의 원시 타입 및 기본 타입
- 코틀린 타입과 자바 타입과의 관계
- 코틀린에서의 컬렉션과 배열 및 이들의 널 가능성과 상호운용성 

### 기본 타입

#### 자바에서의 원시 타입과 참조 타입
- 자바에서는 원시 타입(primitive type)과 참조 타입(reference type)을 구분한다
  - 원시 타입(int, boolean, char 등)의 변수에는 그 값이 직접 들어간다
  - 참조 타입(Integer, Boolean, Character 등)의 변수에는 메모리상의 객체 위치가 들어간다
- 자바에서 원시 타입에 대해 메서드를 호출하거나 컬렉션에 담을 수 없다
  - 참조 타입이 필요한 경우 특별한 래퍼 타입으로 원시 타입을 감싸서 사용한다
  - `Collection<int>`가 아닌 `Collection<Integer>`

#### 코틀린에서의 원시 타입과 참조 타입
- 코틀린은 원시 타입과 래퍼 타입을 구분하지 않고 항상 같은 타입으로 취급한다
  - 그렇다면 모든 타입을 항상 객체로 표현하는 것은 아니고 실행 시점에 가장 효율적인 방식으로 표현된다 
  - 대부분의 경우 코틀린의 숫자 타입은 자바의 원시 타입으로 컴파일 되고, 컬렉션과 같은 제네릭 클래스를 사용하는 경우는 래퍼 타입에 해당하는 객체로 컴파일된다

#### 부호 없는 숫자 타입
- 양수를 표현하기 위해 모든 비트 범위를 사용하고 싶을 때 코틀린은 JVM의 일반적인 원시 타입을 확장해 부호 없는 타입을 제공한다
- 부호 없는 숫자 타입들은 상응하는 부호 있는 타입의 범위를 시프트해서 같은 크기의 메모리를 사용해 더 큰 양수 범위를 표현할 수 있게 한다
- 코틀린의 부호 없는 수도 다른 원시 타입과 마찬가지로 필요할 때만 래핑된다
  - JVM 자체는 부호 없는 수에 대한 원시 타입을 제공하지 않지만 인라인 클래스를 통해 추상화를 제공한다
  - 즉, 메모리에는 Int나 Long 그대로 있다가 코드에서 타입 구분할 때만 UInt, ULong 처럼 행동해 성능 손해 없이 부호 없는 수를 다룬다

| 타입 | 크기 | 값의 범위                                  |
|:--|:--|:---------------------------------------|
| `UByte` | 8비트 (2⁸) | 0 ~ 255 (2⁸-1)                         |
| `UShort` | 16비트 (2¹⁶) | 0 ~ 65,535 (2¹⁶-1)                     |
| `UInt` | 32비트 (2³²) | 0 ~ 4,294,967,295 (2³²-1)              |
| `ULong` | 64비트 (2⁶⁴) | 0 ~ 18,446,744,073,709,551,615 (2⁶⁴-1) |

#### 널이 될 수 있는 원시 타입
- 코틀린의 nullable한 타입은(`Int?`) 자바의 원시 타입으로 표현할 수 없기 때문에 자바의 래퍼 타입으로(`Integer`) 컴파일된다
- 코틀린 컴파일러는 두 값이 nullable할 때 무조건 먼저 null 체크한 뒤 일반적인 값으로 다루도록 허용한다
- 자바 클래스를 가져와서 쓸 때에는 그냥 nullable인지 아닌지만 신경 쓰면 된다. 
  - 내부적으로 알아서 `int` or `Integer` 언박싱/박싱해서 컴파일해준다

**제네릭 클래스의 경우**
- 제네릭 클래스의 경우 JVM은 제네릭 타입이 타입 소거 방식으로 구현되기 때문에 타입 파라미터에 원시 타입을 허용하지 않는다
  - 타입 소거 방식? JVM은 제네릭 타입 정보를 컴파일 이후에 버린다. 즉, 런타임에는 타입 인자가 사라지고 Object처럼 다룬다
    ```kotlin
    fun <T> checkType(value: T) {
        if (value is String) { } // OK
        if (value is T) { } // T가 뭔지 모르므로 불가능
    }
    ```
  - 코틀린은 `inline`과 `reified`의 조합으로 이 타입 소거 문제를 피할 수 있다
    - 함수를 인라인하면 타입 파라미터도 복붙으로 삽입될 수 있어서 타입 정보도 런타입까지 살아남게(`reified`) 할 수 있는 것
    ```kotlin
    inline fun <reified T> checkType(value: Any) {
        if (value is T) println("Yes, it's a ${T::class}")
        else println("No, it's not a ${T::class}")
    }
    
    fun main() {
        checkType<String>("Hello") // Yes, it's a class kotlin.String
        checkType<Int>("Hello")    // No, it's not a class kotlin.Int
    }
    ```
- 따라서 제네릭에선 항상 박스 타입을 사용해야 한다

#### 수 변환
- 코틀린은 한 타입의 수를 다른 타입의 수로 자동 변환하지 않기 때문에 명시적으로 변환 메서드를 사용해야 한다
- 코틀린은 Boolean을 제외한 모든 원시 타입에 대해 양방향 변환 함수를 모두 제공한다
  - 표현 범위가 더 좁은 타입으로 변환하면서 값을 벗어나는 경우에는 일부를 잘라내는 함수도 있다

**숫자 리터럴**
- 보통은 변환 함수 호출 필요 없이 타입을 표현하는 문자를 붙여주기만 하면 된다
- 직접 변환하지 않더라도 숫자 리터럴을 타입이 알려진 변수에 대입하거나 인자로 넘기면 컴파일러가 필요한 변환을 자동으로 해준다
- 산술 연산자는 적당한 타입의 값을 받아들일 수 있도록 이미 오버로드되어 있다
  - ex) Int + Long은 Long 기준

| 종류 | 예시                                 | 설명 |
|:--|:-----------------------------------|:--|
| **10진수(Int, Long 기본)** | `123`, `4567`                      | 일반 정수 |
| **Long** | `123L`, `4567L`                    | 끝에 `L` 또는 `l` 추가 |
| **Unsigned(Int, Long)** | `123u`, `4567U`, `123uL`, `4567UL` | `u` 또는 `U` 접미사로 부호 없는 타입 |
| **16진수** | `0x1F`, `0X1F`                     | 접두사 `0x` 또는 `0X` 사용 |
| **2진수** | `0b1010`, `0B1010`                 | 접두사 `0b` 또는 `0B` 사용 |
| **8진수** | (Kotlin은 8진수 지원 X)                 | 사용 불가 (자바는 지원했지만 코틀린은 아님) |
| **부동소수점(Double 기본)** | `123.45`, `1.0e3`, `3.14E-2`       | 지수 표기 가능 (`e`, `E` 사용) |
| **Float** | `123.45f`, `1.0e3f`, `3.14E-2F`    | 끝에 `f` 또는 `F` 추가 |

**문자 리터럴**

| 리터럴 | 의미 |
|:--|:--|
| `'\n'` | 줄바꿈 (New Line) |
| `'\t'` | 탭 (Tab) |
| `'\b'` | 백스페이스 (Backspace) |
| `'\r'` | 캐리지 리턴 (Carriage Return) |
| `'\''` | 작은따옴표 자체 (Single Quote) |
| `'\"'` | 큰따옴표 자체 (Double Quote) |
| `'\\'` | 역슬래시 자체 (Backslash) |


**문자열 변환**
- 문자열을 원시 타입으로 변환하는 여러 함수를 제공하는데 변환에 실패하면 `NumberFormatException`이 발생한다
- `NumberFormatException`를 명시적으로 처리하기 귀찮을 때에는 실패를 `null`로 돌려주는 함수도 있다
- 문자열이 null이 아니고 정확히 단어 true와 같으면(대소문자 구분 X) Boolean `true`로, 그 외에는 `false`로 변환해주는 `toBoolean`도 있다
- 정확히 `true`나 `false`와 일치시키고 싶을 땐 `toBooleanStrict`를 쓰면 일치하지 않을 때 예외를 던져준다


### Any와 Any?
- 자바의 최상위 타입 `Object`처럼 코틀린은 `Any`가 모든 널이 될 수 없는 타입의 조상 타입이다

